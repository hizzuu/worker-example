This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-15T06:48:43.436Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cmd/
  workerpool/
    main.go
pkg/
  workerpool/
    monitor.go
    result.go
    retry.go
    task.go
    web.go
    worker_pool.go
go.mod

================================================================
Files
================================================================

================
File: cmd/workerpool/main.go
================
package main

import (
	"fmt"
	"time"

	"github.com/hizzuu/worker-example/pkg/workerpool"
)

func main() {
	// 3つのワーカーを持つプールを作成
	pool := workerpool.NewWorkerPool(3)

	// プロセッサを登録
	pool.RegisterProcessor(workerpool.TaskTypeEmail, workerpool.EmailProcessor)
	pool.RegisterProcessor(workerpool.TaskTypeImage, workerpool.ImageProcessor)
	pool.RegisterProcessor(workerpool.TaskTypeDatabase, workerpool.DatabaseProcessor)
	pool.RegisterProcessor(workerpool.TaskTypeReport, workerpool.ReportProcessor)

	// タスクタイムアウトを設定
	pool.SetTaskTimeout(10 * time.Second)

	// 🆕 監視機能を追加
	monitor := workerpool.NewMonitor(pool)
	monitor.Start()
	defer monitor.Stop()

	// 🆕 Web監視画面を開始
	monitor.StartWebServer(8080)

	// ワーカープールを開始
	pool.Start()

	// 大量のタスクを準備（監視機能のテスト用）
	fmt.Println("📝 大量タスクを投入してリアルタイム監視をテストします...")
	fmt.Println("🌐 Web監視画面: http://localhost:8080")

	// タスクを段階的に投入
	go func() {
		for batch := 1; batch <= 5; batch++ {
			fmt.Printf("\n📦 バッチ %d を投入中...\n", batch)

			for i := 1; i <= 4; i++ {
				taskID := (batch-1)*4 + i
				taskTypes := []workerpool.TaskType{
					workerpool.TaskTypeEmail,
					workerpool.TaskTypeImage,
					workerpool.TaskTypeDatabase,
					workerpool.TaskTypeReport,
				}

				task := workerpool.Task{
					ID:   taskID,
					Name: fmt.Sprintf("バッチ%d-タスク%d", batch, i),
					Type: taskTypes[(i-1)%len(taskTypes)],
				}

				pool.AddTask(task)
				time.Sleep(500 * time.Millisecond) // 0.5秒間隔で投入
			}

			time.Sleep(2 * time.Second) // バッチ間の待機
		}
	}()

	// 🆕 定期的に統計情報を表示
	go func() {
		ticker := time.NewTicker(5 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ticker.C:
				monitor.PrintStats()
			}
		}
	}()

	// 結果を取得（タスク完了を監視しながら）
	fmt.Println("\n📊 結果を取得中...")
	totalTasks := 20
	results := make([]workerpool.TaskResult, 0, totalTasks)

	for i := 0; i < totalTasks; i++ {
		result := pool.GetResult()
		results = append(results, result)

		// 🆕 監視機能にタスク結果を通知
		monitor.OnTaskResult(result)

		// 進捗表示
		fmt.Printf("📈 進捗: %d/%d 完了\n", len(results), totalTasks)
	}

	// 最終統計を表示
	fmt.Println("\n🎯 最終結果:")
	var (
		successCount  int
		failureCount  int
		retryCount    int
		totalDuration time.Duration
	)

	for _, result := range results {
		totalDuration += result.TotalDuration
		if result.Success {
			successCount++
			if result.WasRetried() {
				retryCount++
			}
		} else {
			failureCount++
		}
	}

	avgDuration := totalDuration / time.Duration(len(results))
	successRate := float64(successCount) / float64(len(results)) * 100

	fmt.Printf("📊 最終統計:\n")
	fmt.Printf("   総タスク数: %d\n", len(results))
	fmt.Printf("   成功: %d (%.1f%%)\n", successCount, successRate)
	fmt.Printf("   失敗: %d (%.1f%%)\n", failureCount, 100-successRate)
	fmt.Printf("   リトライ成功: %d (%.1f%%)\n", retryCount, float64(retryCount)/float64(len(results))*100)
	fmt.Printf("   平均処理時間: %v\n", avgDuration)

	// 🆕 最終監視統計を表示
	monitor.PrintStats()

	fmt.Println("\n🌐 Web監視画面は http://localhost:8080 で確認できます")
	fmt.Println("📊 JSONデータは http://localhost:8080/stats で取得できます")
	fmt.Println("⏰ 10秒後にシステムを停止します...")

	time.Sleep(10 * time.Second)

	// ワーカープールを停止
	pool.Stop()

	fmt.Println("🎉 すべての処理が完了しました！")
}

================
File: pkg/workerpool/monitor.go
================
package workerpool

import (
	"fmt"
	"sync"
	"time"
)

// PoolStats はワーカープールの統計情報
type PoolStats struct {
	// 基本統計
	TotalTasks     int64 `json:"total_tasks"`
	CompletedTasks int64 `json:"completed_tasks"`
	FailedTasks    int64 `json:"failed_tasks"`
	ActiveTasks    int64 `json:"active_tasks"`
	QueuedTasks    int64 `json:"queued_tasks"`
	RetryingTasks  int64 `json:"retrying_tasks"`

	// ワーカー統計
	TotalWorkers  int `json:"total_workers"`
	ActiveWorkers int `json:"active_workers"`
	IdleWorkers   int `json:"idle_workers"`

	// 処理時間統計
	AverageTime float64 `json:"average_time_ms"`
	MinTime     float64 `json:"min_time_ms"`
	MaxTime     float64 `json:"max_time_ms"`

	// タスクタイプ別統計
	TaskTypeStats map[TaskType]TaskTypeStats `json:"task_type_stats"`

	// システム情報
	Uptime      time.Duration `json:"uptime_ms"`
	LastUpdated time.Time     `json:"last_updated"`
}

// TaskTypeStats はタスクタイプ別の統計
type TaskTypeStats struct {
	Total     int64   `json:"total"`
	Succeeded int64   `json:"succeeded"`
	Failed    int64   `json:"failed"`
	Retried   int64   `json:"retried"`
	AvgTime   float64 `json:"avg_time_ms"`
}

// Monitor はリアルタイム監視機能
type Monitor struct {
	pool      *WorkerPool
	stats     PoolStats
	mutex     sync.RWMutex
	startTime time.Time

	// リアルタイム更新用
	updateCh chan TaskResult
	stopCh   chan struct{}
	wg       sync.WaitGroup
}

// NewMonitor は新しいモニターを作成
func NewMonitor(pool *WorkerPool) *Monitor {
	return &Monitor{
		pool:      pool,
		startTime: time.Now(),
		updateCh:  make(chan TaskResult, 100),
		stopCh:    make(chan struct{}),
		stats: PoolStats{
			TaskTypeStats: make(map[TaskType]TaskTypeStats),
		},
	}
}

// Start はモニタリングを開始
func (m *Monitor) Start() {
	m.wg.Add(1)
	go m.updateLoop()
}

// Stop はモニタリングを停止
func (m *Monitor) Stop() {
	close(m.stopCh)
	m.wg.Wait()
}

// OnTaskResult はタスク結果を受信
func (m *Monitor) OnTaskResult(result TaskResult) {
	select {
	case m.updateCh <- result:
	default:
		// チャネルが満杯の場合はスキップ
	}
}

// updateLoop は統計情報を定期的に更新
func (m *Monitor) updateLoop() {
	defer m.wg.Done()

	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case result := <-m.updateCh:
			m.updateStats(result)

		case <-ticker.C:
			m.updateSystemStats()

		case <-m.stopCh:
			return
		}
	}
}

// updateStats はタスク結果で統計を更新
func (m *Monitor) updateStats(result TaskResult) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	// 基本統計を更新
	m.stats.TotalTasks++
	if result.Success {
		m.stats.CompletedTasks++
	} else {
		m.stats.FailedTasks++
	}

	// 処理時間統計を更新
	timeMs := float64(result.TotalDuration.Nanoseconds()) / 1e6
	if m.stats.TotalTasks == 1 {
		m.stats.MinTime = timeMs
		m.stats.MaxTime = timeMs
		m.stats.AverageTime = timeMs
	} else {
		if timeMs < m.stats.MinTime {
			m.stats.MinTime = timeMs
		}
		if timeMs > m.stats.MaxTime {
			m.stats.MaxTime = timeMs
		}
		// 移動平均を計算
		m.stats.AverageTime = (m.stats.AverageTime*float64(m.stats.TotalTasks-1) + timeMs) / float64(m.stats.TotalTasks)
	}

	// タスクタイプ別統計を更新
	typeStats := m.stats.TaskTypeStats[result.TaskType]
	typeStats.Total++
	if result.Success {
		typeStats.Succeeded++
	} else {
		typeStats.Failed++
	}
	if result.WasRetried() {
		typeStats.Retried++
	}

	// タスクタイプ別平均時間を更新
	if typeStats.Total == 1 {
		typeStats.AvgTime = timeMs
	} else {
		typeStats.AvgTime = (typeStats.AvgTime*float64(typeStats.Total-1) + timeMs) / float64(typeStats.Total)
	}

	m.stats.TaskTypeStats[result.TaskType] = typeStats
	m.stats.LastUpdated = time.Now()
}

// updateSystemStats はシステム統計を更新
func (m *Monitor) updateSystemStats() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	m.stats.Uptime = time.Since(m.startTime)
	m.stats.TotalWorkers = m.pool.workers

	// キューの長さを取得（近似値）
	m.stats.QueuedTasks = int64(len(m.pool.tasks))
	m.stats.RetryingTasks = int64(len(m.pool.retryQueue))

	// アクティブワーカー数は実装により異なる（ここでは推定）
	m.stats.ActiveWorkers = m.stats.TotalWorkers
	m.stats.IdleWorkers = 0
}

// GetStats は現在の統計情報を取得
func (m *Monitor) GetStats() PoolStats {
	m.mutex.RLock()
	defer m.mutex.RUnlock()

	// ディープコピーを返す
	stats := m.stats
	stats.TaskTypeStats = make(map[TaskType]TaskTypeStats)
	for k, v := range m.stats.TaskTypeStats {
		stats.TaskTypeStats[k] = v
	}

	return stats
}

// PrintStats はコンソールに統計情報を表示
func (m *Monitor) PrintStats() {
	stats := m.GetStats()

	fmt.Println("\n📊 === リアルタイム統計情報 ===")
	fmt.Printf("稼働時間: %v\n", stats.Uptime.Round(time.Second))
	fmt.Printf("総タスク数: %d | 完了: %d | 失敗: %d\n",
		stats.TotalTasks, stats.CompletedTasks, stats.FailedTasks)
	fmt.Printf("キュー: %d | リトライ中: %d\n",
		stats.QueuedTasks, stats.RetryingTasks)
	fmt.Printf("ワーカー: %d/%d アクティブ\n",
		stats.ActiveWorkers, stats.TotalWorkers)
	fmt.Printf("処理時間: 平均 %.1fms | 最小 %.1fms | 最大 %.1fms\n",
		stats.AverageTime, stats.MinTime, stats.MaxTime)

	if len(stats.TaskTypeStats) > 0 {
		fmt.Println("\n📋 タスクタイプ別統計:")
		for taskType, typeStats := range stats.TaskTypeStats {
			successRate := float64(typeStats.Succeeded) / float64(typeStats.Total) * 100
			fmt.Printf("  [%s] 総数:%d 成功:%d 失敗:%d リトライ:%d 成功率:%.1f%% 平均:%.1fms\n",
				taskType, typeStats.Total, typeStats.Succeeded, typeStats.Failed,
				typeStats.Retried, successRate, typeStats.AvgTime)
		}
	}
	fmt.Println("==================================================")
}

================
File: pkg/workerpool/result.go
================
package workerpool

import "time"

type TaskResult struct {
	TaskID        int
	TaskName      string
	TaskType      TaskType
	Success       bool
	Error         error
	Duration      time.Duration
	TotalDuration time.Duration // リトライ含む総処理時間
	WorkerID      int
	StartTime     time.Time
	EndTime       time.Time
	AttemptCount  int  // 試行回数
	IsFinal       bool // 最終結果かどうか
}

func (tr *TaskResult) IsTimeout() bool {
	if tr.Error == nil {
		return false
	}

	return tr.Error.Error() == "context deadline exceeded"
}

func (tr *TaskResult) GetErrorType() string {
	if tr.Error == nil {
		return ""
	}

	errorMsg := tr.Error.Error()
	switch {
	case tr.IsTimeout():
		return "TIMEOUT"
	case len(errorMsg) > 0:
		if len(errorMsg) > 20 {
			return errorMsg[:20] // エラーメッセージが長い場合は先頭20文字を返す
		}
		return errorMsg
	default:
		return "UNKNOWN"
	}
}

func (tr *TaskResult) WasRetried() bool {
	return tr.AttemptCount > 1
}

================
File: pkg/workerpool/retry.go
================
package workerpool

import (
	"time"
)

type RetryPolicy struct {
	MaxRetries      int           // 最大リトライ回数
	InitialDelay    time.Duration // 初回リトライまでの遅延
	MaxDelay        time.Duration // 最大遅延時間
	BackoffFactor   float64       // バックオフ係数
	RetryableErrors []string      // リトライ対象のエラーパターン
}

func DefaultRetryPolicy() RetryPolicy {
	return RetryPolicy{
		MaxRetries:    3,
		InitialDelay:  1 * time.Second,
		MaxDelay:      30 * time.Second,
		BackoffFactor: 2.0,
		RetryableErrors: []string{
			"SMTP接続エラー",
			"データベース接続エラー",
			"context deadline exceeded", // タイムアウト
		},
	}
}

func TaskTypeRetryPolicies() map[TaskType]RetryPolicy {
	return map[TaskType]RetryPolicy{
		TaskTypeEmail: {
			MaxRetries:      5, // メールは重要なので多めにリトライ
			InitialDelay:    2 * time.Second,
			MaxDelay:        60 * time.Second,
			BackoffFactor:   2.0,
			RetryableErrors: []string{"SMTP接続エラー"},
		},
		TaskTypeImage: {
			MaxRetries:      2, // 画像処理は重くないのでリトライ少なめ
			InitialDelay:    5 * time.Second,
			MaxDelay:        30 * time.Second,
			BackoffFactor:   1.5,
			RetryableErrors: []string{}, // 形式エラーは基本的にリトライしない
		},
		TaskTypeDatabase: {
			MaxRetries:      4, // データベースは接続エラーが多いので多めに
			InitialDelay:    1 * time.Second,
			MaxDelay:        20 * time.Second,
			BackoffFactor:   2.5,
			RetryableErrors: []string{"データベース接続エラー", "context deadline exceeded"},
		},
		TaskTypeReport: {
			MaxRetries:      3,
			InitialDelay:    10 * time.Second, // レポートは重い処理なので待機時間長め
			MaxDelay:        120 * time.Second,
			BackoffFactor:   2.0,
			RetryableErrors: []string{"データ不整合エラー"},
		},
	}
}

func (rp *RetryPolicy) CalculateRetryDelay(attemptCount int) time.Duration {
	if attemptCount <= 0 {
		return rp.InitialDelay
	}

	// 指数バックオフ計算
	delay := float64(rp.InitialDelay) * (rp.BackoffFactor * float64(attemptCount))
	delayDuration := time.Duration(delay)

	// 最大遅延時間を超えないように制限
	if delayDuration > rp.MaxDelay {
		return rp.MaxDelay
	}

	return delayDuration
}

// ShouldRetry はエラーがリトライ対象かどうかを判定
func (rp *RetryPolicy) ShouldRetry(err error, attemptCount int) bool {
	if err == nil {
		return false
	}

	if attemptCount >= rp.MaxRetries {
		return false
	}

	errorMsg := err.Error()
	for _, retryableError := range rp.RetryableErrors {
		if len(retryableError) > 0 && len(errorMsg) >= len(retryableError) {
			if errorMsg[:len(retryableError)] == retryableError {
				return true
			}
		}
	}

	return false
}

================
File: pkg/workerpool/task.go
================
package workerpool

import (
	"context"
	"errors"
	"math/rand"
	"time"
)

type Task struct {
	ID           int
	Name         string
	Type         TaskType
	Payload      interface{}
	AttemptCount int       // リトライ回数
	MaxRetries   int       // 最大リトライ回数
	LastError    error     // 最後のエラー
	CreatedAt    time.Time // タスクの作成日時
	FirstAttempt time.Time // 最初の試行日時
}

type TaskType string

const (
	TaskTypeEmail    TaskType = "email"
	TaskTypeImage    TaskType = "image"
	TaskTypeDatabase TaskType = "database"
	TaskTypeReport   TaskType = "report"
)

type TaskProcessor func(ctx context.Context, task Task) error

func EmailProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(1+rand.Intn(2)) * time.Second

	select {
	case <-time.After(processingTime):
		// 最初の試行では20%失敗、リトライでは10%失敗（改善される想定）
		failureRate := 20
		if task.AttemptCount > 0 {
			failureRate = 10
		}

		if rand.Intn(100) < failureRate {
			return errors.New("SMTP接続エラー: メール送信に失敗しました")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

func ImageProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(2+rand.Intn(4)) * time.Second

	select {
	case <-time.After(processingTime):
		// 画像形式エラーはリトライしても改善されないことが多い
		if rand.Intn(10) < 2 {
			return errors.New("画像形式エラー: サポートされていない形式です")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

func DatabaseProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(1+rand.Intn(3)) * time.Second

	select {
	case <-time.After(processingTime):
		// データベース接続は時間が経つと改善されることが多い
		failureRate := 10
		if task.AttemptCount > 1 {
			failureRate = 3 // リトライで大幅改善
		}

		if rand.Intn(100) < failureRate {
			return errors.New("データベース接続エラー: タイムアウトしました")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

func ReportProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(3+rand.Intn(3)) * time.Second

	select {
	case <-time.After(processingTime):
		// データ不整合は時間が経つと解決される場合がある
		failureRate := 15
		if task.AttemptCount > 0 {
			failureRate = 8
		}

		if rand.Intn(100) < failureRate {
			return errors.New("データ不整合エラー: レポート生成に必要なデータが不足しています")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

================
File: pkg/workerpool/web.go
================
package workerpool

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// StartWebServer は統計情報をHTTPで公開
func (m *Monitor) StartWebServer(port int) {
	http.HandleFunc("/stats", func(w http.ResponseWriter, r *http.Request) {
		stats := m.GetStats()
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Access-Control-Allow-Origin", "*")
		json.NewEncoder(w).Encode(stats)
	})

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		fmt.Fprintf(w, getHTMLTemplate())
	})

	fmt.Printf("🌐 Web監視画面: http://localhost:%d\n", port)
	fmt.Printf("📊 JSON API: http://localhost:%d/stats\n", port)
	go http.ListenAndServe(fmt.Sprintf(":%d", port), nil)
}

// getHTMLTemplate はHTMLテンプレートを返す
func getHTMLTemplate() string {
	return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worker Pool Monitor</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 20px; 
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #007acc, #0099ff);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .stats { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px;
        }
        .card { 
            border: 1px solid #ddd; 
            padding: 20px; 
            border-radius: 10px; 
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .metric { 
            font-size: 28px; 
            font-weight: bold; 
            color: #007acc; 
            margin: 10px 0;
        }
        .label { 
            color: #666; 
            font-size: 14px; 
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        .success { color: #28a745; }
        .failure { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #17a2b8; }
        .refresh { 
            margin: 10px 0; 
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .refresh-flex {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
        }
        .task-types {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .task-type-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 12px 10px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }
        .task-type-header {
            font-weight: bold;
            background: #f8f9fa;
            padding: 15px 10px;
            color: #495057;
        }
        .pulse {
            animation: pulse 1.5s ease-in-out;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
            100% { opacity: 1; transform: scale(1); }
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-running { background-color: #28a745; }
        .status-warning { background-color: #ffc107; }
        .status-error { background-color: #dc3545; }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
            }
            .task-type-row {
                grid-template-columns: 1fr 60px 60px 60px 70px 80px;
                gap: 8px;
                font-size: 14px;
            }
            .refresh-flex {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
    <script>
        let lastUpdateTime = 0;
        
        function updateStats() {
            fetch('/stats')
                .then(response => response.json())
                .then(data => {
                    console.log('Stats received:', data); // デバッグ用
                    
                    // 基本統計の更新
                    updateElement('total-tasks', data.total_tasks || 0);
                    updateElement('completed-tasks', data.completed_tasks || 0);
                    updateElement('failed-tasks', data.failed_tasks || 0);
                    updateElement('queued-tasks', data.queued_tasks || 0);
                    updateElement('retrying-tasks', data.retrying_tasks || 0);
                    updateElement('active-workers', (data.active_workers || 0) + '/' + (data.total_workers || 0));
                    updateElement('avg-time', (data.average_time_ms || 0).toFixed(1) + 'ms');
                    updateElement('min-time', (data.min_time_ms || 0).toFixed(1) + 'ms');
                    updateElement('max-time', (data.max_time_ms || 0).toFixed(1) + 'ms');
                    updateElement('uptime', formatUptime(data.uptime_ms || 0));
                    
                    const successRate = data.total_tasks > 0 ? (data.completed_tasks / data.total_tasks * 100).toFixed(1) : 0;
                    updateElement('success-rate', successRate + '%');
                    
                    // 最終更新時刻の処理
                    const currentTime = new Date(data.last_updated).getTime();
                    if (currentTime > lastUpdateTime && data.last_updated) {
                        const updateTimeElement = document.getElementById('last-updated');
                        updateTimeElement.textContent = new Date(data.last_updated).toLocaleTimeString('ja-JP');
                        updateTimeElement.className = 'pulse';
                        updateTimeElement.style.color = '';
                        setTimeout(() => {
                            updateTimeElement.className = '';
                        }, 1500);
                        lastUpdateTime = currentTime;
                    }
                    
                    // タスクタイプ別統計の更新
                    updateTaskTypeStats(data.task_type_stats);
                    
                    // システム状態インジケーターの更新
                    updateSystemStatus(data);
                })
                .catch(error => {
                    console.error('Error fetching stats:', error);
                    const updateTimeElement = document.getElementById('last-updated');
                    updateTimeElement.textContent = 'エラー';
                    updateTimeElement.style.color = '#dc3545';
                });
        }
        
        function updateElement(id, value) {
            const element = document.getElementById(id);
            if (element && element.textContent !== String(value)) {
                element.textContent = value;
                element.classList.add('pulse');
                setTimeout(() => element.classList.remove('pulse'), 1500);
            }
        }
        
        function formatUptime(uptimeMs) {
            const seconds = Math.floor(uptimeMs / 1000000 / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return hours + 'h ' + minutes + 'm ' + secs + 's';
            } else if (minutes > 0) {
                return minutes + 'm ' + secs + 's';
            } else {
                return secs + 's';
            }
        }
        
        function updateTaskTypeStats(taskTypeStats) {
            const container = document.getElementById('task-types-container');
            if (!taskTypeStats || Object.keys(taskTypeStats).length === 0) {
                container.innerHTML = '<div class="loading">タスクタイプ別統計はまだありません</div>';
                return;
            }
            
            let html = '<div class="task-type-header task-type-row">';
            html += '<div>タスクタイプ</div>';
            html += '<div>総数</div>';
            html += '<div>成功</div>';
            html += '<div>失敗</div>';
            html += '<div>成功率</div>';
            html += '<div>平均時間</div>';
            html += '</div>';
            
            Object.keys(taskTypeStats).sort().forEach(taskType => {
                const stats = taskTypeStats[taskType];
                const successRate = stats.total > 0 ? (stats.succeeded / stats.total * 100).toFixed(1) : 0;
                const statusColor = successRate >= 90 ? 'success' : successRate >= 70 ? 'warning' : 'failure';
                
                html += '<div class="task-type-row">';
                html += '<div><strong>' + taskType + '</strong></div>';
                html += '<div>' + stats.total + '</div>';
                html += '<div class="success">' + stats.succeeded + '</div>';
                html += '<div class="failure">' + stats.failed + '</div>';
                html += '<div class="' + statusColor + '">' + successRate + '%</div>';
                html += '<div>' + stats.avg_time_ms.toFixed(1) + 'ms</div>';
                html += '</div>';
            });
            
            container.innerHTML = html;
        }
        
        function updateSystemStatus(data) {
            const statusElement = document.getElementById('system-status');
            let statusClass = 'status-running';
            let statusText = '正常稼働中';
            
            if (data.failed_tasks > 0 && data.total_tasks > 0) {
                const failureRate = (data.failed_tasks / data.total_tasks) * 100;
                if (failureRate > 20) {
                    statusClass = 'status-error';
                    statusText = '高エラー率';
                } else if (failureRate > 10) {
                    statusClass = 'status-warning';
                    statusText = '注意が必要';
                }
            }
            
            if (data.retrying_tasks > 5) {
                statusClass = 'status-warning';
                statusText = 'リトライ多数';
            }
            
            statusElement.innerHTML = '<span class="status-indicator ' + statusClass + '"></span>' + statusText;
        }
        
        // 1秒ごとに更新
        setInterval(updateStats, 1000);
        
        // 初回読み込み
        document.addEventListener('DOMContentLoaded', function() {
            updateStats();
        });
    </script>
</head>
<body>
    <div class="header">
        <h1>🚀 Worker Pool Monitor</h1>
        <div>リアルタイム監視ダッシュボード</div>
    </div>
    
    <div class="refresh">
        <div class="refresh-flex">
            <div>最終更新: <span id="last-updated">読み込み中...</span></div>
            <div>システム状態: <span id="system-status">起動中...</span></div>
        </div>
    </div>
    
    <div class="stats">
        <div class="card">
            <div class="label">総タスク数</div>
            <div class="metric info" id="total-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">完了タスク</div>
            <div class="metric success" id="completed-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">失敗タスク</div>
            <div class="metric failure" id="failed-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">成功率</div>
            <div class="metric" id="success-rate">0%</div>
        </div>
        <div class="card">
            <div class="label">キューイング中</div>
            <div class="metric warning" id="queued-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">リトライ中</div>
            <div class="metric warning" id="retrying-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">ワーカー数</div>
            <div class="metric info" id="active-workers">0/0</div>
        </div>
        <div class="card">
            <div class="label">平均処理時間</div>
            <div class="metric" id="avg-time">0ms</div>
        </div>
        <div class="card">
            <div class="label">最小処理時間</div>
            <div class="metric" id="min-time">0ms</div>
        </div>
        <div class="card">
            <div class="label">最大処理時間</div>
            <div class="metric" id="max-time">0ms</div>
        </div>
        <div class="card">
            <div class="label">稼働時間</div>
            <div class="metric info" id="uptime">0s</div>
        </div>
    </div>
    
    <div class="task-types">
        <h3>📋 タスクタイプ別統計</h3>
        <div id="task-types-container" class="loading">
            データを読み込み中...
        </div>
    </div>
</body>
</html>`
}

================
File: pkg/workerpool/worker_pool.go
================
package workerpool

import (
	"context"
	"fmt"
	"sync"
	"time"
)

type WorkerPool struct {
	tasks         chan Task
	retryQueue    chan Task
	results       chan TaskResult
	workers       int
	wg            sync.WaitGroup
	retryWg       sync.WaitGroup
	processors    map[TaskType]TaskProcessor
	retryPolicies map[TaskType]RetryPolicy
	taskTimeout   time.Duration
	shutdownCh    chan struct{} // 🆕 シャットダウン用チャネル
}

func NewWorkerPool(workers int) *WorkerPool {
	return &WorkerPool{
		tasks:         make(chan Task, 10),
		retryQueue:    make(chan Task, 50), // リトライキューは大きめに
		results:       make(chan TaskResult, 10),
		workers:       workers,
		processors:    make(map[TaskType]TaskProcessor),
		retryPolicies: TaskTypeRetryPolicies(), // デフォルトポリシーを設定
		taskTimeout:   30 * time.Second,
		shutdownCh:    make(chan struct{}),
	}
}

func (wp *WorkerPool) RegisterProcessor(taskType TaskType, processor TaskProcessor) {
	wp.processors[taskType] = processor
}

func (wp *WorkerPool) SetTaskTimeout(timeout time.Duration) {
	wp.taskTimeout = timeout
}

func (wp *WorkerPool) SetRetryPolicy(taskType TaskType, policy RetryPolicy) {
	wp.retryPolicies[taskType] = policy
}

func (wp *WorkerPool) Start() {
	fmt.Printf("🚀 %d個のワーカーを開始します\n", wp.workers)

	for i := 0; i < wp.workers; i++ {
		wp.wg.Add(1)
		go wp.worker(i)
	}

	wp.retryWg.Add(1)
	go wp.retryHandler()
}

func (wp *WorkerPool) worker(id int) {
	defer wp.wg.Done()

	fmt.Printf("👷 ワーカー %d が開始されました\n", id)

	for task := range wp.tasks {
		wp.executeTask(task, id)
	}

	fmt.Printf("🛑 ワーカー %d が終了しました\n", id)
}

// リトライハンドラー
func (wp *WorkerPool) retryHandler() {
	defer wp.retryWg.Done()

	fmt.Println("🔄 リトライハンドラーが開始されました")

	for {
		select {
		case task := <-wp.retryQueue:
			policy, exists := wp.retryPolicies[task.Type]
			if !exists {
				policy = DefaultRetryPolicy()
			}

			// リトライ遅延を計算
			delay := policy.CalculateRetryDelay(task.AttemptCount)
			fmt.Printf("⏰ タスク %d を %v 後にリトライします (試行回数: %d/%d)\n",
				task.ID, delay, task.AttemptCount+1, policy.MaxRetries+1)

			// 遅延後にメインキューに戻す
			time.Sleep(delay)

			select {
			case wp.tasks <- task:
				fmt.Printf("🔄 タスク %d をリトライキューから戻しました\n", task.ID)
			case <-wp.shutdownCh:
				return
			}

		case <-wp.shutdownCh:
			fmt.Println("🛑 リトライハンドラーが終了しました")
			return
		}
	}
}

func (wp *WorkerPool) executeTask(task Task, workerID int) {
	startTime := time.Now()
	if task.FirstAttempt.IsZero() {
		task.FirstAttempt = startTime // 最初の試行日時を設定
	}

	attemptInfo := ""
	if task.AttemptCount > 0 {
		attemptInfo = fmt.Sprintf(" (リトライ %d回目)", task.AttemptCount)
	}

	fmt.Printf("⚡ ワーカー %d がタスク %d (%s:%s) を処理中...%s\n", workerID, task.ID, task.Type, task.Name, attemptInfo)

	// タスクを実行
	var err error
	processor, exists := wp.processors[task.Type]
	if !exists {
		err = fmt.Errorf("タスクタイプ %s のプロセッサが登録されていません", task.Type)
	} else {
		ctx, cancel := context.WithTimeout(context.Background(), wp.taskTimeout)
		err = processor(ctx, task)
		cancel()
	}

	endTime := time.Now()
	duration := endTime.Sub(startTime)
	totalDuration := endTime.Sub(task.FirstAttempt)

	if err != nil {
		// リトライ判定
		policy, exists := wp.retryPolicies[task.Type]
		if !exists {
			policy = DefaultRetryPolicy()
		}

		if policy.ShouldRetry(err, task.AttemptCount) {
			fmt.Printf("🔄 ワーカー %d: タスク %d が失敗、リトライします (エラー: %v)\n",
				workerID, task.ID, err)

			// リトライ用にタスクを更新
			task.AttemptCount++
			task.LastError = err

			// リトライキューに送信
			select {
			case wp.retryQueue <- task:
			default:
				// リトライキューが満杯の場合は失敗として処理
				fmt.Printf("⚠️ リトライキューが満杯のため、タスク %d を失敗として処理します\n", task.ID)
				wp.sendResult(task, err, duration, totalDuration, workerID, false)
			}
			return
		} else {
			fmt.Printf("❌ ワーカー %d: タスク %d が最終的に失敗 (試行回数: %d, エラー: %v)\n",
				workerID, task.ID, task.AttemptCount+1, err)
		}
	} else {
		successInfo := ""
		if task.AttemptCount > 0 {
			successInfo = fmt.Sprintf(" (%d回目で成功)", task.AttemptCount+1)
		}
		fmt.Printf("✅ ワーカー %d がタスク %d を完了%s (処理時間: %v, 総時間: %v)\n",
			workerID, task.ID, successInfo, duration, totalDuration)
	}

	wp.sendResult(task, err, duration, totalDuration, workerID, true)
}

func (wp *WorkerPool) sendResult(task Task, err error, duration, totalDuration time.Duration, workerID int, isFinal bool) {
	result := TaskResult{
		TaskID:        task.ID,
		TaskName:      task.Name,
		TaskType:      task.Type,
		Success:       err == nil,
		Error:         err,
		Duration:      duration,
		TotalDuration: totalDuration, // 🆕 リトライ含む総処理時間
		WorkerID:      workerID,
		StartTime:     task.FirstAttempt,
		EndTime:       time.Now(),
		AttemptCount:  task.AttemptCount + 1, // 🆕 試行回数
		IsFinal:       isFinal,               // 🆕 最終結果かどうか
	}

	wp.results <- result
}

func (wp *WorkerPool) AddTask(task Task) {
	wp.tasks <- task
	fmt.Printf("📥 タスク %d (%s) がキューに追加されました\n", task.ID, task.Name)
}

// 🆕 結果を取得する関数
func (wp *WorkerPool) GetResult() TaskResult {
	return <-wp.results
}

// 🆕 指定した数の結果を取得する関数
func (wp *WorkerPool) GetResults(count int) []TaskResult {
	results := make([]TaskResult, 0, count)
	for i := 0; i < count; i++ {
		result := <-wp.results
		results = append(results, result)
	}
	return results
}

func (wp *WorkerPool) Stop() {
	fmt.Println("🔄 ワーカープールを停止中...")

	// シャットダウンシグナルを送信
	close(wp.shutdownCh)

	close(wp.tasks) // タスクチャネルを閉じる
	wp.wg.Wait()    // すべてのワーカーの完了を待つ

	close(wp.retryQueue) // リトライキューを閉じる
	wp.retryWg.Wait()    // リトライハンドラーの完了を待つ

	close(wp.results) // 結果チャネルも閉じる
	fmt.Println("✋ ワーカープールが停止しました")
}

================
File: go.mod
================
module github.com/hizzuu/worker-example

go 1.23.5
