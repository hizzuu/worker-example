This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-15T06:48:43.436Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cmd/
  workerpool/
    main.go
pkg/
  workerpool/
    monitor.go
    result.go
    retry.go
    task.go
    web.go
    worker_pool.go
go.mod

================================================================
Files
================================================================

================
File: cmd/workerpool/main.go
================
package main

import (
	"fmt"
	"time"

	"github.com/hizzuu/worker-example/pkg/workerpool"
)

func main() {
	// 3ã¤ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’æŒã¤ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆ
	pool := workerpool.NewWorkerPool(3)

	// ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’ç™»éŒ²
	pool.RegisterProcessor(workerpool.TaskTypeEmail, workerpool.EmailProcessor)
	pool.RegisterProcessor(workerpool.TaskTypeImage, workerpool.ImageProcessor)
	pool.RegisterProcessor(workerpool.TaskTypeDatabase, workerpool.DatabaseProcessor)
	pool.RegisterProcessor(workerpool.TaskTypeReport, workerpool.ReportProcessor)

	// ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®š
	pool.SetTaskTimeout(10 * time.Second)

	// ğŸ†• ç›£è¦–æ©Ÿèƒ½ã‚’è¿½åŠ 
	monitor := workerpool.NewMonitor(pool)
	monitor.Start()
	defer monitor.Stop()

	// ğŸ†• Webç›£è¦–ç”»é¢ã‚’é–‹å§‹
	monitor.StartWebServer(8080)

	// ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«ã‚’é–‹å§‹
	pool.Start()

	// å¤§é‡ã®ã‚¿ã‚¹ã‚¯ã‚’æº–å‚™ï¼ˆç›£è¦–æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆç”¨ï¼‰
	fmt.Println("ğŸ“ å¤§é‡ã‚¿ã‚¹ã‚¯ã‚’æŠ•å…¥ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™...")
	fmt.Println("ğŸŒ Webç›£è¦–ç”»é¢: http://localhost:8080")

	// ã‚¿ã‚¹ã‚¯ã‚’æ®µéšçš„ã«æŠ•å…¥
	go func() {
		for batch := 1; batch <= 5; batch++ {
			fmt.Printf("\nğŸ“¦ ãƒãƒƒãƒ %d ã‚’æŠ•å…¥ä¸­...\n", batch)

			for i := 1; i <= 4; i++ {
				taskID := (batch-1)*4 + i
				taskTypes := []workerpool.TaskType{
					workerpool.TaskTypeEmail,
					workerpool.TaskTypeImage,
					workerpool.TaskTypeDatabase,
					workerpool.TaskTypeReport,
				}

				task := workerpool.Task{
					ID:   taskID,
					Name: fmt.Sprintf("ãƒãƒƒãƒ%d-ã‚¿ã‚¹ã‚¯%d", batch, i),
					Type: taskTypes[(i-1)%len(taskTypes)],
				}

				pool.AddTask(task)
				time.Sleep(500 * time.Millisecond) // 0.5ç§’é–“éš”ã§æŠ•å…¥
			}

			time.Sleep(2 * time.Second) // ãƒãƒƒãƒé–“ã®å¾…æ©Ÿ
		}
	}()

	// ğŸ†• å®šæœŸçš„ã«çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º
	go func() {
		ticker := time.NewTicker(5 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ticker.C:
				monitor.PrintStats()
			}
		}
	}()

	// çµæœã‚’å–å¾—ï¼ˆã‚¿ã‚¹ã‚¯å®Œäº†ã‚’ç›£è¦–ã—ãªãŒã‚‰ï¼‰
	fmt.Println("\nğŸ“Š çµæœã‚’å–å¾—ä¸­...")
	totalTasks := 20
	results := make([]workerpool.TaskResult, 0, totalTasks)

	for i := 0; i < totalTasks; i++ {
		result := pool.GetResult()
		results = append(results, result)

		// ğŸ†• ç›£è¦–æ©Ÿèƒ½ã«ã‚¿ã‚¹ã‚¯çµæœã‚’é€šçŸ¥
		monitor.OnTaskResult(result)

		// é€²æ—è¡¨ç¤º
		fmt.Printf("ğŸ“ˆ é€²æ—: %d/%d å®Œäº†\n", len(results), totalTasks)
	}

	// æœ€çµ‚çµ±è¨ˆã‚’è¡¨ç¤º
	fmt.Println("\nğŸ¯ æœ€çµ‚çµæœ:")
	var (
		successCount  int
		failureCount  int
		retryCount    int
		totalDuration time.Duration
	)

	for _, result := range results {
		totalDuration += result.TotalDuration
		if result.Success {
			successCount++
			if result.WasRetried() {
				retryCount++
			}
		} else {
			failureCount++
		}
	}

	avgDuration := totalDuration / time.Duration(len(results))
	successRate := float64(successCount) / float64(len(results)) * 100

	fmt.Printf("ğŸ“Š æœ€çµ‚çµ±è¨ˆ:\n")
	fmt.Printf("   ç·ã‚¿ã‚¹ã‚¯æ•°: %d\n", len(results))
	fmt.Printf("   æˆåŠŸ: %d (%.1f%%)\n", successCount, successRate)
	fmt.Printf("   å¤±æ•—: %d (%.1f%%)\n", failureCount, 100-successRate)
	fmt.Printf("   ãƒªãƒˆãƒ©ã‚¤æˆåŠŸ: %d (%.1f%%)\n", retryCount, float64(retryCount)/float64(len(results))*100)
	fmt.Printf("   å¹³å‡å‡¦ç†æ™‚é–“: %v\n", avgDuration)

	// ğŸ†• æœ€çµ‚ç›£è¦–çµ±è¨ˆã‚’è¡¨ç¤º
	monitor.PrintStats()

	fmt.Println("\nğŸŒ Webç›£è¦–ç”»é¢ã¯ http://localhost:8080 ã§ç¢ºèªã§ãã¾ã™")
	fmt.Println("ğŸ“Š JSONãƒ‡ãƒ¼ã‚¿ã¯ http://localhost:8080/stats ã§å–å¾—ã§ãã¾ã™")
	fmt.Println("â° 10ç§’å¾Œã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åœæ­¢ã—ã¾ã™...")

	time.Sleep(10 * time.Second)

	// ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«ã‚’åœæ­¢
	pool.Stop()

	fmt.Println("ğŸ‰ ã™ã¹ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼")
}

================
File: pkg/workerpool/monitor.go
================
package workerpool

import (
	"fmt"
	"sync"
	"time"
)

// PoolStats ã¯ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«ã®çµ±è¨ˆæƒ…å ±
type PoolStats struct {
	// åŸºæœ¬çµ±è¨ˆ
	TotalTasks     int64 `json:"total_tasks"`
	CompletedTasks int64 `json:"completed_tasks"`
	FailedTasks    int64 `json:"failed_tasks"`
	ActiveTasks    int64 `json:"active_tasks"`
	QueuedTasks    int64 `json:"queued_tasks"`
	RetryingTasks  int64 `json:"retrying_tasks"`

	// ãƒ¯ãƒ¼ã‚«ãƒ¼çµ±è¨ˆ
	TotalWorkers  int `json:"total_workers"`
	ActiveWorkers int `json:"active_workers"`
	IdleWorkers   int `json:"idle_workers"`

	// å‡¦ç†æ™‚é–“çµ±è¨ˆ
	AverageTime float64 `json:"average_time_ms"`
	MinTime     float64 `json:"min_time_ms"`
	MaxTime     float64 `json:"max_time_ms"`

	// ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ
	TaskTypeStats map[TaskType]TaskTypeStats `json:"task_type_stats"`

	// ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
	Uptime      time.Duration `json:"uptime_ms"`
	LastUpdated time.Time     `json:"last_updated"`
}

// TaskTypeStats ã¯ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥ã®çµ±è¨ˆ
type TaskTypeStats struct {
	Total     int64   `json:"total"`
	Succeeded int64   `json:"succeeded"`
	Failed    int64   `json:"failed"`
	Retried   int64   `json:"retried"`
	AvgTime   float64 `json:"avg_time_ms"`
}

// Monitor ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–æ©Ÿèƒ½
type Monitor struct {
	pool      *WorkerPool
	stats     PoolStats
	mutex     sync.RWMutex
	startTime time.Time

	// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ç”¨
	updateCh chan TaskResult
	stopCh   chan struct{}
	wg       sync.WaitGroup
}

// NewMonitor ã¯æ–°ã—ã„ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’ä½œæˆ
func NewMonitor(pool *WorkerPool) *Monitor {
	return &Monitor{
		pool:      pool,
		startTime: time.Now(),
		updateCh:  make(chan TaskResult, 100),
		stopCh:    make(chan struct{}),
		stats: PoolStats{
			TaskTypeStats: make(map[TaskType]TaskTypeStats),
		},
	}
}

// Start ã¯ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚’é–‹å§‹
func (m *Monitor) Start() {
	m.wg.Add(1)
	go m.updateLoop()
}

// Stop ã¯ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚’åœæ­¢
func (m *Monitor) Stop() {
	close(m.stopCh)
	m.wg.Wait()
}

// OnTaskResult ã¯ã‚¿ã‚¹ã‚¯çµæœã‚’å—ä¿¡
func (m *Monitor) OnTaskResult(result TaskResult) {
	select {
	case m.updateCh <- result:
	default:
		// ãƒãƒ£ãƒãƒ«ãŒæº€æ¯ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
	}
}

// updateLoop ã¯çµ±è¨ˆæƒ…å ±ã‚’å®šæœŸçš„ã«æ›´æ–°
func (m *Monitor) updateLoop() {
	defer m.wg.Done()

	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case result := <-m.updateCh:
			m.updateStats(result)

		case <-ticker.C:
			m.updateSystemStats()

		case <-m.stopCh:
			return
		}
	}
}

// updateStats ã¯ã‚¿ã‚¹ã‚¯çµæœã§çµ±è¨ˆã‚’æ›´æ–°
func (m *Monitor) updateStats(result TaskResult) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	// åŸºæœ¬çµ±è¨ˆã‚’æ›´æ–°
	m.stats.TotalTasks++
	if result.Success {
		m.stats.CompletedTasks++
	} else {
		m.stats.FailedTasks++
	}

	// å‡¦ç†æ™‚é–“çµ±è¨ˆã‚’æ›´æ–°
	timeMs := float64(result.TotalDuration.Nanoseconds()) / 1e6
	if m.stats.TotalTasks == 1 {
		m.stats.MinTime = timeMs
		m.stats.MaxTime = timeMs
		m.stats.AverageTime = timeMs
	} else {
		if timeMs < m.stats.MinTime {
			m.stats.MinTime = timeMs
		}
		if timeMs > m.stats.MaxTime {
			m.stats.MaxTime = timeMs
		}
		// ç§»å‹•å¹³å‡ã‚’è¨ˆç®—
		m.stats.AverageTime = (m.stats.AverageTime*float64(m.stats.TotalTasks-1) + timeMs) / float64(m.stats.TotalTasks)
	}

	// ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆã‚’æ›´æ–°
	typeStats := m.stats.TaskTypeStats[result.TaskType]
	typeStats.Total++
	if result.Success {
		typeStats.Succeeded++
	} else {
		typeStats.Failed++
	}
	if result.WasRetried() {
		typeStats.Retried++
	}

	// ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥å¹³å‡æ™‚é–“ã‚’æ›´æ–°
	if typeStats.Total == 1 {
		typeStats.AvgTime = timeMs
	} else {
		typeStats.AvgTime = (typeStats.AvgTime*float64(typeStats.Total-1) + timeMs) / float64(typeStats.Total)
	}

	m.stats.TaskTypeStats[result.TaskType] = typeStats
	m.stats.LastUpdated = time.Now()
}

// updateSystemStats ã¯ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã‚’æ›´æ–°
func (m *Monitor) updateSystemStats() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	m.stats.Uptime = time.Since(m.startTime)
	m.stats.TotalWorkers = m.pool.workers

	// ã‚­ãƒ¥ãƒ¼ã®é•·ã•ã‚’å–å¾—ï¼ˆè¿‘ä¼¼å€¤ï¼‰
	m.stats.QueuedTasks = int64(len(m.pool.tasks))
	m.stats.RetryingTasks = int64(len(m.pool.retryQueue))

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¯ãƒ¼ã‚«ãƒ¼æ•°ã¯å®Ÿè£…ã«ã‚ˆã‚Šç•°ãªã‚‹ï¼ˆã“ã“ã§ã¯æ¨å®šï¼‰
	m.stats.ActiveWorkers = m.stats.TotalWorkers
	m.stats.IdleWorkers = 0
}

// GetStats ã¯ç¾åœ¨ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
func (m *Monitor) GetStats() PoolStats {
	m.mutex.RLock()
	defer m.mutex.RUnlock()

	// ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã‚’è¿”ã™
	stats := m.stats
	stats.TaskTypeStats = make(map[TaskType]TaskTypeStats)
	for k, v := range m.stats.TaskTypeStats {
		stats.TaskTypeStats[k] = v
	}

	return stats
}

// PrintStats ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º
func (m *Monitor) PrintStats() {
	stats := m.GetStats()

	fmt.Println("\nğŸ“Š === ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çµ±è¨ˆæƒ…å ± ===")
	fmt.Printf("ç¨¼åƒæ™‚é–“: %v\n", stats.Uptime.Round(time.Second))
	fmt.Printf("ç·ã‚¿ã‚¹ã‚¯æ•°: %d | å®Œäº†: %d | å¤±æ•—: %d\n",
		stats.TotalTasks, stats.CompletedTasks, stats.FailedTasks)
	fmt.Printf("ã‚­ãƒ¥ãƒ¼: %d | ãƒªãƒˆãƒ©ã‚¤ä¸­: %d\n",
		stats.QueuedTasks, stats.RetryingTasks)
	fmt.Printf("ãƒ¯ãƒ¼ã‚«ãƒ¼: %d/%d ã‚¢ã‚¯ãƒ†ã‚£ãƒ–\n",
		stats.ActiveWorkers, stats.TotalWorkers)
	fmt.Printf("å‡¦ç†æ™‚é–“: å¹³å‡ %.1fms | æœ€å° %.1fms | æœ€å¤§ %.1fms\n",
		stats.AverageTime, stats.MinTime, stats.MaxTime)

	if len(stats.TaskTypeStats) > 0 {
		fmt.Println("\nğŸ“‹ ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ:")
		for taskType, typeStats := range stats.TaskTypeStats {
			successRate := float64(typeStats.Succeeded) / float64(typeStats.Total) * 100
			fmt.Printf("  [%s] ç·æ•°:%d æˆåŠŸ:%d å¤±æ•—:%d ãƒªãƒˆãƒ©ã‚¤:%d æˆåŠŸç‡:%.1f%% å¹³å‡:%.1fms\n",
				taskType, typeStats.Total, typeStats.Succeeded, typeStats.Failed,
				typeStats.Retried, successRate, typeStats.AvgTime)
		}
	}
	fmt.Println("==================================================")
}

================
File: pkg/workerpool/result.go
================
package workerpool

import "time"

type TaskResult struct {
	TaskID        int
	TaskName      string
	TaskType      TaskType
	Success       bool
	Error         error
	Duration      time.Duration
	TotalDuration time.Duration // ãƒªãƒˆãƒ©ã‚¤å«ã‚€ç·å‡¦ç†æ™‚é–“
	WorkerID      int
	StartTime     time.Time
	EndTime       time.Time
	AttemptCount  int  // è©¦è¡Œå›æ•°
	IsFinal       bool // æœ€çµ‚çµæœã‹ã©ã†ã‹
}

func (tr *TaskResult) IsTimeout() bool {
	if tr.Error == nil {
		return false
	}

	return tr.Error.Error() == "context deadline exceeded"
}

func (tr *TaskResult) GetErrorType() string {
	if tr.Error == nil {
		return ""
	}

	errorMsg := tr.Error.Error()
	switch {
	case tr.IsTimeout():
		return "TIMEOUT"
	case len(errorMsg) > 0:
		if len(errorMsg) > 20 {
			return errorMsg[:20] // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•·ã„å ´åˆã¯å…ˆé ­20æ–‡å­—ã‚’è¿”ã™
		}
		return errorMsg
	default:
		return "UNKNOWN"
	}
}

func (tr *TaskResult) WasRetried() bool {
	return tr.AttemptCount > 1
}

================
File: pkg/workerpool/retry.go
================
package workerpool

import (
	"time"
)

type RetryPolicy struct {
	MaxRetries      int           // æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
	InitialDelay    time.Duration // åˆå›ãƒªãƒˆãƒ©ã‚¤ã¾ã§ã®é…å»¶
	MaxDelay        time.Duration // æœ€å¤§é…å»¶æ™‚é–“
	BackoffFactor   float64       // ãƒãƒƒã‚¯ã‚ªãƒ•ä¿‚æ•°
	RetryableErrors []string      // ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
}

func DefaultRetryPolicy() RetryPolicy {
	return RetryPolicy{
		MaxRetries:    3,
		InitialDelay:  1 * time.Second,
		MaxDelay:      30 * time.Second,
		BackoffFactor: 2.0,
		RetryableErrors: []string{
			"SMTPæ¥ç¶šã‚¨ãƒ©ãƒ¼",
			"ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼",
			"context deadline exceeded", // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
		},
	}
}

func TaskTypeRetryPolicies() map[TaskType]RetryPolicy {
	return map[TaskType]RetryPolicy{
		TaskTypeEmail: {
			MaxRetries:      5, // ãƒ¡ãƒ¼ãƒ«ã¯é‡è¦ãªã®ã§å¤šã‚ã«ãƒªãƒˆãƒ©ã‚¤
			InitialDelay:    2 * time.Second,
			MaxDelay:        60 * time.Second,
			BackoffFactor:   2.0,
			RetryableErrors: []string{"SMTPæ¥ç¶šã‚¨ãƒ©ãƒ¼"},
		},
		TaskTypeImage: {
			MaxRetries:      2, // ç”»åƒå‡¦ç†ã¯é‡ããªã„ã®ã§ãƒªãƒˆãƒ©ã‚¤å°‘ãªã‚
			InitialDelay:    5 * time.Second,
			MaxDelay:        30 * time.Second,
			BackoffFactor:   1.5,
			RetryableErrors: []string{}, // å½¢å¼ã‚¨ãƒ©ãƒ¼ã¯åŸºæœ¬çš„ã«ãƒªãƒˆãƒ©ã‚¤ã—ãªã„
		},
		TaskTypeDatabase: {
			MaxRetries:      4, // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯æ¥ç¶šã‚¨ãƒ©ãƒ¼ãŒå¤šã„ã®ã§å¤šã‚ã«
			InitialDelay:    1 * time.Second,
			MaxDelay:        20 * time.Second,
			BackoffFactor:   2.5,
			RetryableErrors: []string{"ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼", "context deadline exceeded"},
		},
		TaskTypeReport: {
			MaxRetries:      3,
			InitialDelay:    10 * time.Second, // ãƒ¬ãƒãƒ¼ãƒˆã¯é‡ã„å‡¦ç†ãªã®ã§å¾…æ©Ÿæ™‚é–“é•·ã‚
			MaxDelay:        120 * time.Second,
			BackoffFactor:   2.0,
			RetryableErrors: []string{"ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã‚¨ãƒ©ãƒ¼"},
		},
	}
}

func (rp *RetryPolicy) CalculateRetryDelay(attemptCount int) time.Duration {
	if attemptCount <= 0 {
		return rp.InitialDelay
	}

	// æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•è¨ˆç®—
	delay := float64(rp.InitialDelay) * (rp.BackoffFactor * float64(attemptCount))
	delayDuration := time.Duration(delay)

	// æœ€å¤§é…å»¶æ™‚é–“ã‚’è¶…ãˆãªã„ã‚ˆã†ã«åˆ¶é™
	if delayDuration > rp.MaxDelay {
		return rp.MaxDelay
	}

	return delayDuration
}

// ShouldRetry ã¯ã‚¨ãƒ©ãƒ¼ãŒãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã‹ã©ã†ã‹ã‚’åˆ¤å®š
func (rp *RetryPolicy) ShouldRetry(err error, attemptCount int) bool {
	if err == nil {
		return false
	}

	if attemptCount >= rp.MaxRetries {
		return false
	}

	errorMsg := err.Error()
	for _, retryableError := range rp.RetryableErrors {
		if len(retryableError) > 0 && len(errorMsg) >= len(retryableError) {
			if errorMsg[:len(retryableError)] == retryableError {
				return true
			}
		}
	}

	return false
}

================
File: pkg/workerpool/task.go
================
package workerpool

import (
	"context"
	"errors"
	"math/rand"
	"time"
)

type Task struct {
	ID           int
	Name         string
	Type         TaskType
	Payload      interface{}
	AttemptCount int       // ãƒªãƒˆãƒ©ã‚¤å›æ•°
	MaxRetries   int       // æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
	LastError    error     // æœ€å¾Œã®ã‚¨ãƒ©ãƒ¼
	CreatedAt    time.Time // ã‚¿ã‚¹ã‚¯ã®ä½œæˆæ—¥æ™‚
	FirstAttempt time.Time // æœ€åˆã®è©¦è¡Œæ—¥æ™‚
}

type TaskType string

const (
	TaskTypeEmail    TaskType = "email"
	TaskTypeImage    TaskType = "image"
	TaskTypeDatabase TaskType = "database"
	TaskTypeReport   TaskType = "report"
)

type TaskProcessor func(ctx context.Context, task Task) error

func EmailProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(1+rand.Intn(2)) * time.Second

	select {
	case <-time.After(processingTime):
		// æœ€åˆã®è©¦è¡Œã§ã¯20%å¤±æ•—ã€ãƒªãƒˆãƒ©ã‚¤ã§ã¯10%å¤±æ•—ï¼ˆæ”¹å–„ã•ã‚Œã‚‹æƒ³å®šï¼‰
		failureRate := 20
		if task.AttemptCount > 0 {
			failureRate = 10
		}

		if rand.Intn(100) < failureRate {
			return errors.New("SMTPæ¥ç¶šã‚¨ãƒ©ãƒ¼: ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

func ImageProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(2+rand.Intn(4)) * time.Second

	select {
	case <-time.After(processingTime):
		// ç”»åƒå½¢å¼ã‚¨ãƒ©ãƒ¼ã¯ãƒªãƒˆãƒ©ã‚¤ã—ã¦ã‚‚æ”¹å–„ã•ã‚Œãªã„ã“ã¨ãŒå¤šã„
		if rand.Intn(10) < 2 {
			return errors.New("ç”»åƒå½¢å¼ã‚¨ãƒ©ãƒ¼: ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼ã§ã™")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

func DatabaseProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(1+rand.Intn(3)) * time.Second

	select {
	case <-time.After(processingTime):
		// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã¯æ™‚é–“ãŒçµŒã¤ã¨æ”¹å–„ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„
		failureRate := 10
		if task.AttemptCount > 1 {
			failureRate = 3 // ãƒªãƒˆãƒ©ã‚¤ã§å¤§å¹…æ”¹å–„
		}

		if rand.Intn(100) < failureRate {
			return errors.New("ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

func ReportProcessor(ctx context.Context, task Task) error {
	processingTime := time.Duration(3+rand.Intn(3)) * time.Second

	select {
	case <-time.After(processingTime):
		// ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã¯æ™‚é–“ãŒçµŒã¤ã¨è§£æ±ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹
		failureRate := 15
		if task.AttemptCount > 0 {
			failureRate = 8
		}

		if rand.Intn(100) < failureRate {
			return errors.New("ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã‚¨ãƒ©ãƒ¼: ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
		}
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

================
File: pkg/workerpool/web.go
================
package workerpool

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// StartWebServer ã¯çµ±è¨ˆæƒ…å ±ã‚’HTTPã§å…¬é–‹
func (m *Monitor) StartWebServer(port int) {
	http.HandleFunc("/stats", func(w http.ResponseWriter, r *http.Request) {
		stats := m.GetStats()
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Access-Control-Allow-Origin", "*")
		json.NewEncoder(w).Encode(stats)
	})

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		fmt.Fprintf(w, getHTMLTemplate())
	})

	fmt.Printf("ğŸŒ Webç›£è¦–ç”»é¢: http://localhost:%d\n", port)
	fmt.Printf("ğŸ“Š JSON API: http://localhost:%d/stats\n", port)
	go http.ListenAndServe(fmt.Sprintf(":%d", port), nil)
}

// getHTMLTemplate ã¯HTMLãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¿”ã™
func getHTMLTemplate() string {
	return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worker Pool Monitor</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 20px; 
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #007acc, #0099ff);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .stats { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px;
        }
        .card { 
            border: 1px solid #ddd; 
            padding: 20px; 
            border-radius: 10px; 
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .metric { 
            font-size: 28px; 
            font-weight: bold; 
            color: #007acc; 
            margin: 10px 0;
        }
        .label { 
            color: #666; 
            font-size: 14px; 
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        .success { color: #28a745; }
        .failure { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #17a2b8; }
        .refresh { 
            margin: 10px 0; 
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .refresh-flex {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
        }
        .task-types {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .task-type-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 12px 10px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }
        .task-type-header {
            font-weight: bold;
            background: #f8f9fa;
            padding: 15px 10px;
            color: #495057;
        }
        .pulse {
            animation: pulse 1.5s ease-in-out;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
            100% { opacity: 1; transform: scale(1); }
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-running { background-color: #28a745; }
        .status-warning { background-color: #ffc107; }
        .status-error { background-color: #dc3545; }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
            }
            .task-type-row {
                grid-template-columns: 1fr 60px 60px 60px 70px 80px;
                gap: 8px;
                font-size: 14px;
            }
            .refresh-flex {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
    <script>
        let lastUpdateTime = 0;
        
        function updateStats() {
            fetch('/stats')
                .then(response => response.json())
                .then(data => {
                    console.log('Stats received:', data); // ãƒ‡ãƒãƒƒã‚°ç”¨
                    
                    // åŸºæœ¬çµ±è¨ˆã®æ›´æ–°
                    updateElement('total-tasks', data.total_tasks || 0);
                    updateElement('completed-tasks', data.completed_tasks || 0);
                    updateElement('failed-tasks', data.failed_tasks || 0);
                    updateElement('queued-tasks', data.queued_tasks || 0);
                    updateElement('retrying-tasks', data.retrying_tasks || 0);
                    updateElement('active-workers', (data.active_workers || 0) + '/' + (data.total_workers || 0));
                    updateElement('avg-time', (data.average_time_ms || 0).toFixed(1) + 'ms');
                    updateElement('min-time', (data.min_time_ms || 0).toFixed(1) + 'ms');
                    updateElement('max-time', (data.max_time_ms || 0).toFixed(1) + 'ms');
                    updateElement('uptime', formatUptime(data.uptime_ms || 0));
                    
                    const successRate = data.total_tasks > 0 ? (data.completed_tasks / data.total_tasks * 100).toFixed(1) : 0;
                    updateElement('success-rate', successRate + '%');
                    
                    // æœ€çµ‚æ›´æ–°æ™‚åˆ»ã®å‡¦ç†
                    const currentTime = new Date(data.last_updated).getTime();
                    if (currentTime > lastUpdateTime && data.last_updated) {
                        const updateTimeElement = document.getElementById('last-updated');
                        updateTimeElement.textContent = new Date(data.last_updated).toLocaleTimeString('ja-JP');
                        updateTimeElement.className = 'pulse';
                        updateTimeElement.style.color = '';
                        setTimeout(() => {
                            updateTimeElement.className = '';
                        }, 1500);
                        lastUpdateTime = currentTime;
                    }
                    
                    // ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆã®æ›´æ–°
                    updateTaskTypeStats(data.task_type_stats);
                    
                    // ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®æ›´æ–°
                    updateSystemStatus(data);
                })
                .catch(error => {
                    console.error('Error fetching stats:', error);
                    const updateTimeElement = document.getElementById('last-updated');
                    updateTimeElement.textContent = 'ã‚¨ãƒ©ãƒ¼';
                    updateTimeElement.style.color = '#dc3545';
                });
        }
        
        function updateElement(id, value) {
            const element = document.getElementById(id);
            if (element && element.textContent !== String(value)) {
                element.textContent = value;
                element.classList.add('pulse');
                setTimeout(() => element.classList.remove('pulse'), 1500);
            }
        }
        
        function formatUptime(uptimeMs) {
            const seconds = Math.floor(uptimeMs / 1000000 / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return hours + 'h ' + minutes + 'm ' + secs + 's';
            } else if (minutes > 0) {
                return minutes + 'm ' + secs + 's';
            } else {
                return secs + 's';
            }
        }
        
        function updateTaskTypeStats(taskTypeStats) {
            const container = document.getElementById('task-types-container');
            if (!taskTypeStats || Object.keys(taskTypeStats).length === 0) {
                container.innerHTML = '<div class="loading">ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }
            
            let html = '<div class="task-type-header task-type-row">';
            html += '<div>ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—</div>';
            html += '<div>ç·æ•°</div>';
            html += '<div>æˆåŠŸ</div>';
            html += '<div>å¤±æ•—</div>';
            html += '<div>æˆåŠŸç‡</div>';
            html += '<div>å¹³å‡æ™‚é–“</div>';
            html += '</div>';
            
            Object.keys(taskTypeStats).sort().forEach(taskType => {
                const stats = taskTypeStats[taskType];
                const successRate = stats.total > 0 ? (stats.succeeded / stats.total * 100).toFixed(1) : 0;
                const statusColor = successRate >= 90 ? 'success' : successRate >= 70 ? 'warning' : 'failure';
                
                html += '<div class="task-type-row">';
                html += '<div><strong>' + taskType + '</strong></div>';
                html += '<div>' + stats.total + '</div>';
                html += '<div class="success">' + stats.succeeded + '</div>';
                html += '<div class="failure">' + stats.failed + '</div>';
                html += '<div class="' + statusColor + '">' + successRate + '%</div>';
                html += '<div>' + stats.avg_time_ms.toFixed(1) + 'ms</div>';
                html += '</div>';
            });
            
            container.innerHTML = html;
        }
        
        function updateSystemStatus(data) {
            const statusElement = document.getElementById('system-status');
            let statusClass = 'status-running';
            let statusText = 'æ­£å¸¸ç¨¼åƒä¸­';
            
            if (data.failed_tasks > 0 && data.total_tasks > 0) {
                const failureRate = (data.failed_tasks / data.total_tasks) * 100;
                if (failureRate > 20) {
                    statusClass = 'status-error';
                    statusText = 'é«˜ã‚¨ãƒ©ãƒ¼ç‡';
                } else if (failureRate > 10) {
                    statusClass = 'status-warning';
                    statusText = 'æ³¨æ„ãŒå¿…è¦';
                }
            }
            
            if (data.retrying_tasks > 5) {
                statusClass = 'status-warning';
                statusText = 'ãƒªãƒˆãƒ©ã‚¤å¤šæ•°';
            }
            
            statusElement.innerHTML = '<span class="status-indicator ' + statusClass + '"></span>' + statusText;
        }
        
        // 1ç§’ã”ã¨ã«æ›´æ–°
        setInterval(updateStats, 1000);
        
        // åˆå›èª­ã¿è¾¼ã¿
        document.addEventListener('DOMContentLoaded', function() {
            updateStats();
        });
    </script>
</head>
<body>
    <div class="header">
        <h1>ğŸš€ Worker Pool Monitor</h1>
        <div>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</div>
    </div>
    
    <div class="refresh">
        <div class="refresh-flex">
            <div>æœ€çµ‚æ›´æ–°: <span id="last-updated">èª­ã¿è¾¼ã¿ä¸­...</span></div>
            <div>ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹: <span id="system-status">èµ·å‹•ä¸­...</span></div>
        </div>
    </div>
    
    <div class="stats">
        <div class="card">
            <div class="label">ç·ã‚¿ã‚¹ã‚¯æ•°</div>
            <div class="metric info" id="total-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">å®Œäº†ã‚¿ã‚¹ã‚¯</div>
            <div class="metric success" id="completed-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">å¤±æ•—ã‚¿ã‚¹ã‚¯</div>
            <div class="metric failure" id="failed-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">æˆåŠŸç‡</div>
            <div class="metric" id="success-rate">0%</div>
        </div>
        <div class="card">
            <div class="label">ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°ä¸­</div>
            <div class="metric warning" id="queued-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">ãƒªãƒˆãƒ©ã‚¤ä¸­</div>
            <div class="metric warning" id="retrying-tasks">0</div>
        </div>
        <div class="card">
            <div class="label">ãƒ¯ãƒ¼ã‚«ãƒ¼æ•°</div>
            <div class="metric info" id="active-workers">0/0</div>
        </div>
        <div class="card">
            <div class="label">å¹³å‡å‡¦ç†æ™‚é–“</div>
            <div class="metric" id="avg-time">0ms</div>
        </div>
        <div class="card">
            <div class="label">æœ€å°å‡¦ç†æ™‚é–“</div>
            <div class="metric" id="min-time">0ms</div>
        </div>
        <div class="card">
            <div class="label">æœ€å¤§å‡¦ç†æ™‚é–“</div>
            <div class="metric" id="max-time">0ms</div>
        </div>
        <div class="card">
            <div class="label">ç¨¼åƒæ™‚é–“</div>
            <div class="metric info" id="uptime">0s</div>
        </div>
    </div>
    
    <div class="task-types">
        <h3>ğŸ“‹ ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ</h3>
        <div id="task-types-container" class="loading">
            ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...
        </div>
    </div>
</body>
</html>`
}

================
File: pkg/workerpool/worker_pool.go
================
package workerpool

import (
	"context"
	"fmt"
	"sync"
	"time"
)

type WorkerPool struct {
	tasks         chan Task
	retryQueue    chan Task
	results       chan TaskResult
	workers       int
	wg            sync.WaitGroup
	retryWg       sync.WaitGroup
	processors    map[TaskType]TaskProcessor
	retryPolicies map[TaskType]RetryPolicy
	taskTimeout   time.Duration
	shutdownCh    chan struct{} // ğŸ†• ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ç”¨ãƒãƒ£ãƒãƒ«
}

func NewWorkerPool(workers int) *WorkerPool {
	return &WorkerPool{
		tasks:         make(chan Task, 10),
		retryQueue:    make(chan Task, 50), // ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ã¯å¤§ãã‚ã«
		results:       make(chan TaskResult, 10),
		workers:       workers,
		processors:    make(map[TaskType]TaskProcessor),
		retryPolicies: TaskTypeRetryPolicies(), // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒªã‚·ãƒ¼ã‚’è¨­å®š
		taskTimeout:   30 * time.Second,
		shutdownCh:    make(chan struct{}),
	}
}

func (wp *WorkerPool) RegisterProcessor(taskType TaskType, processor TaskProcessor) {
	wp.processors[taskType] = processor
}

func (wp *WorkerPool) SetTaskTimeout(timeout time.Duration) {
	wp.taskTimeout = timeout
}

func (wp *WorkerPool) SetRetryPolicy(taskType TaskType, policy RetryPolicy) {
	wp.retryPolicies[taskType] = policy
}

func (wp *WorkerPool) Start() {
	fmt.Printf("ğŸš€ %då€‹ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’é–‹å§‹ã—ã¾ã™\n", wp.workers)

	for i := 0; i < wp.workers; i++ {
		wp.wg.Add(1)
		go wp.worker(i)
	}

	wp.retryWg.Add(1)
	go wp.retryHandler()
}

func (wp *WorkerPool) worker(id int) {
	defer wp.wg.Done()

	fmt.Printf("ğŸ‘· ãƒ¯ãƒ¼ã‚«ãƒ¼ %d ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ\n", id)

	for task := range wp.tasks {
		wp.executeTask(task, id)
	}

	fmt.Printf("ğŸ›‘ ãƒ¯ãƒ¼ã‚«ãƒ¼ %d ãŒçµ‚äº†ã—ã¾ã—ãŸ\n", id)
}

// ãƒªãƒˆãƒ©ã‚¤ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
func (wp *WorkerPool) retryHandler() {
	defer wp.retryWg.Done()

	fmt.Println("ğŸ”„ ãƒªãƒˆãƒ©ã‚¤ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ")

	for {
		select {
		case task := <-wp.retryQueue:
			policy, exists := wp.retryPolicies[task.Type]
			if !exists {
				policy = DefaultRetryPolicy()
			}

			// ãƒªãƒˆãƒ©ã‚¤é…å»¶ã‚’è¨ˆç®—
			delay := policy.CalculateRetryDelay(task.AttemptCount)
			fmt.Printf("â° ã‚¿ã‚¹ã‚¯ %d ã‚’ %v å¾Œã«ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ (è©¦è¡Œå›æ•°: %d/%d)\n",
				task.ID, delay, task.AttemptCount+1, policy.MaxRetries+1)

			// é…å»¶å¾Œã«ãƒ¡ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ã«æˆ»ã™
			time.Sleep(delay)

			select {
			case wp.tasks <- task:
				fmt.Printf("ğŸ”„ ã‚¿ã‚¹ã‚¯ %d ã‚’ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ã‹ã‚‰æˆ»ã—ã¾ã—ãŸ\n", task.ID)
			case <-wp.shutdownCh:
				return
			}

		case <-wp.shutdownCh:
			fmt.Println("ğŸ›‘ ãƒªãƒˆãƒ©ã‚¤ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒçµ‚äº†ã—ã¾ã—ãŸ")
			return
		}
	}
}

func (wp *WorkerPool) executeTask(task Task, workerID int) {
	startTime := time.Now()
	if task.FirstAttempt.IsZero() {
		task.FirstAttempt = startTime // æœ€åˆã®è©¦è¡Œæ—¥æ™‚ã‚’è¨­å®š
	}

	attemptInfo := ""
	if task.AttemptCount > 0 {
		attemptInfo = fmt.Sprintf(" (ãƒªãƒˆãƒ©ã‚¤ %då›ç›®)", task.AttemptCount)
	}

	fmt.Printf("âš¡ ãƒ¯ãƒ¼ã‚«ãƒ¼ %d ãŒã‚¿ã‚¹ã‚¯ %d (%s:%s) ã‚’å‡¦ç†ä¸­...%s\n", workerID, task.ID, task.Type, task.Name, attemptInfo)

	// ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
	var err error
	processor, exists := wp.processors[task.Type]
	if !exists {
		err = fmt.Errorf("ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ— %s ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“", task.Type)
	} else {
		ctx, cancel := context.WithTimeout(context.Background(), wp.taskTimeout)
		err = processor(ctx, task)
		cancel()
	}

	endTime := time.Now()
	duration := endTime.Sub(startTime)
	totalDuration := endTime.Sub(task.FirstAttempt)

	if err != nil {
		// ãƒªãƒˆãƒ©ã‚¤åˆ¤å®š
		policy, exists := wp.retryPolicies[task.Type]
		if !exists {
			policy = DefaultRetryPolicy()
		}

		if policy.ShouldRetry(err, task.AttemptCount) {
			fmt.Printf("ğŸ”„ ãƒ¯ãƒ¼ã‚«ãƒ¼ %d: ã‚¿ã‚¹ã‚¯ %d ãŒå¤±æ•—ã€ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ (ã‚¨ãƒ©ãƒ¼: %v)\n",
				workerID, task.ID, err)

			// ãƒªãƒˆãƒ©ã‚¤ç”¨ã«ã‚¿ã‚¹ã‚¯ã‚’æ›´æ–°
			task.AttemptCount++
			task.LastError = err

			// ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ã«é€ä¿¡
			select {
			case wp.retryQueue <- task:
			default:
				// ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ãŒæº€æ¯ã®å ´åˆã¯å¤±æ•—ã¨ã—ã¦å‡¦ç†
				fmt.Printf("âš ï¸ ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ãŒæº€æ¯ã®ãŸã‚ã€ã‚¿ã‚¹ã‚¯ %d ã‚’å¤±æ•—ã¨ã—ã¦å‡¦ç†ã—ã¾ã™\n", task.ID)
				wp.sendResult(task, err, duration, totalDuration, workerID, false)
			}
			return
		} else {
			fmt.Printf("âŒ ãƒ¯ãƒ¼ã‚«ãƒ¼ %d: ã‚¿ã‚¹ã‚¯ %d ãŒæœ€çµ‚çš„ã«å¤±æ•— (è©¦è¡Œå›æ•°: %d, ã‚¨ãƒ©ãƒ¼: %v)\n",
				workerID, task.ID, task.AttemptCount+1, err)
		}
	} else {
		successInfo := ""
		if task.AttemptCount > 0 {
			successInfo = fmt.Sprintf(" (%då›ç›®ã§æˆåŠŸ)", task.AttemptCount+1)
		}
		fmt.Printf("âœ… ãƒ¯ãƒ¼ã‚«ãƒ¼ %d ãŒã‚¿ã‚¹ã‚¯ %d ã‚’å®Œäº†%s (å‡¦ç†æ™‚é–“: %v, ç·æ™‚é–“: %v)\n",
			workerID, task.ID, successInfo, duration, totalDuration)
	}

	wp.sendResult(task, err, duration, totalDuration, workerID, true)
}

func (wp *WorkerPool) sendResult(task Task, err error, duration, totalDuration time.Duration, workerID int, isFinal bool) {
	result := TaskResult{
		TaskID:        task.ID,
		TaskName:      task.Name,
		TaskType:      task.Type,
		Success:       err == nil,
		Error:         err,
		Duration:      duration,
		TotalDuration: totalDuration, // ğŸ†• ãƒªãƒˆãƒ©ã‚¤å«ã‚€ç·å‡¦ç†æ™‚é–“
		WorkerID:      workerID,
		StartTime:     task.FirstAttempt,
		EndTime:       time.Now(),
		AttemptCount:  task.AttemptCount + 1, // ğŸ†• è©¦è¡Œå›æ•°
		IsFinal:       isFinal,               // ğŸ†• æœ€çµ‚çµæœã‹ã©ã†ã‹
	}

	wp.results <- result
}

func (wp *WorkerPool) AddTask(task Task) {
	wp.tasks <- task
	fmt.Printf("ğŸ“¥ ã‚¿ã‚¹ã‚¯ %d (%s) ãŒã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã¾ã—ãŸ\n", task.ID, task.Name)
}

// ğŸ†• çµæœã‚’å–å¾—ã™ã‚‹é–¢æ•°
func (wp *WorkerPool) GetResult() TaskResult {
	return <-wp.results
}

// ğŸ†• æŒ‡å®šã—ãŸæ•°ã®çµæœã‚’å–å¾—ã™ã‚‹é–¢æ•°
func (wp *WorkerPool) GetResults(count int) []TaskResult {
	results := make([]TaskResult, 0, count)
	for i := 0; i < count; i++ {
		result := <-wp.results
		results = append(results, result)
	}
	return results
}

func (wp *WorkerPool) Stop() {
	fmt.Println("ğŸ”„ ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«ã‚’åœæ­¢ä¸­...")

	// ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã‚·ã‚°ãƒŠãƒ«ã‚’é€ä¿¡
	close(wp.shutdownCh)

	close(wp.tasks) // ã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒãƒ«ã‚’é–‰ã˜ã‚‹
	wp.wg.Wait()    // ã™ã¹ã¦ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã®å®Œäº†ã‚’å¾…ã¤

	close(wp.retryQueue) // ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
	wp.retryWg.Wait()    // ãƒªãƒˆãƒ©ã‚¤ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å®Œäº†ã‚’å¾…ã¤

	close(wp.results) // çµæœãƒãƒ£ãƒãƒ«ã‚‚é–‰ã˜ã‚‹
	fmt.Println("âœ‹ ãƒ¯ãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¼ãƒ«ãŒåœæ­¢ã—ã¾ã—ãŸ")
}

================
File: go.mod
================
module github.com/hizzuu/worker-example

go 1.23.5
